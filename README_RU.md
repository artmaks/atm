# Задач про банкомат

Есть банкомат, который содержит N купюр разных номиналов. Пользователь хочет снять сумму S из банкомата.
Напишите функцию, которая выдаст данную сумму, используя минимально возможное количество купюр.
Функция должна вернуть массив чисел, либо `null`, если снять данную сумму невозможно.

**Например:**

Купюры в банкомате: [1000, 1000, 500, 500, 100, 100, 100]
Сумма для снятия: 1600
Результат: [1000, 500, 100]


# Жадный алгоритм (Greedy)

Жадный алгоритм – это алгоритм, который принимает локально оптимальное решение на каждом шагу, предполагая что конечное общее решение будет оптимальным.

В данном случае жадный алгоритм можно выразить следующим образом:

1. Берем максимальную купюру, которая меньше или равна необходимой сумме
2. Записываем эту купюру в результат и вычитаем ее из общей суммы
3. Повторяем первый шаг, пока мы не выдали всю сумму

%% СМОТРИ РЕШЕНИЕ В greedy.js %%

**Рассмотрим пример:**

Купюры в банкомате: [5000, 1000, 500, 500, 100]
Сумма для снятия: 1600

1. 5000 не подходит (больше максимальной суммы)
2. 1000 подходит (меньше 1600), остаток 600 (1600 - 1000)
3. 500 подходит (меньше 600), остаток 100 (600 - 500)
4. 100 подходит (равно 100), остаток 0 (100 - 100)
5. Остаток 0, результат [1000, 500, 100]

**Проблема жадного алгоритма:**

Для того чтобы жадный алгоритм давал оптимальное решение, необходимо быть уверенным, что последовательность локально оптимальных выборов дает глобально оптимальное решение.

К сожалению, данная задача не всегда дает оптимальное решение используя жадный алгоритм.

**Рассмотрим пример:**

Купюры в банкомате: [1000, 800, 500, 100, 100, 100]
Сумма для снятия: 1300

1. 1000 подходит (меньше 1300), остаток 300 (1300 - 1000)
2. 800 не подходит (больше 300)
3. 500 не подходит (больше 300)
4. 100 подходит (меньше 100), остаток 200 (300 - 100)
5. 100 подходит (меньше 100), остаток 100 (200 - 100)
6. 100 подходит (меньше 100), остаток 0 (100 - 100)
7. Остаток 0, результат [1000, 100, 100, 100]

Результат `[1000, 100, 100, 100]` не оптимальный, так как данную сумму можно выдать двумя купюрами `[800, 500]`.
На первом шаге мы приняли локально верное решение, но в общем картине это решение неоптимальное.

# Перебор всех вариантов

Для того чтобы найти оптимальное решение переберем все возможные комбинации и запишем сумму для каждой:

[1000, -, -, -, -, -]       = 1000
[-, 800, -, -, -, -]        = 800s
[1000, 800, -, -, -, -]     = 1800
[-, -, 500, -, -, -]        = 500
...

В конце найдем все решения с нужной суммой и выберем решение с наименьшим количеством купюр.

Данный алгоритм будет иметь сложность O(2^N). Если в банкомате содержится 20 купюр, то придется перебрать 1.048.576 вариантов.

Для решение этой задачи более оптимальным способом используем алгоритм динамического программирования.

# Динамическое программирование

Это подход к решению задач, основанный на разбиении задач на подзадачи. Обычно подзадачи отличаются лишь входным значением.

Классический пример — числа фибоначчи. Прежде чем вычислить F(N) мы вычисляем F(N - 1). И таким образом доходим до подзадачи F(0), для которой ответ будет 1.

Обычно при решении задач динамическим программированием мы записываем результат решения каждой подзадачи в таблицу.

**Пример:**

Купюры в банкомате: [1000, 500, 100]
Сумма для снятия: 1100

Заведем таблицу и запишем в нее значения F(N), где N количество купюр:

**F(0)**

Из 0 купюр мы можем получить только сумму 0:

| Сумма    | Купюры  |
| -------- | ------- |
| 0        | []      |

**F(1)**

Добавляем купюру 1000 и получаем 2 варианта:

| Сумма    | Купюры  |
| -------- | ------- |
| 0        | []      |
| 1000     | [1000]  |

**F(2)**

Добавляем к старой таблице 500, получаем 2 новых варианта:

| Сумма    | Купюры      |
| -------- | ----------- |
| 0        | []          |
| 1000     | [1000]      |
| 500      | [500]       |
| 1500     | [1000, 500] |

**F(3)**

Добавляем к старой таблице 100, получаем 4 новых варианта:

| Сумма    | Купюры           |
| -------- | ---------------- |
| 0        | []               |
| 1000     | [1000]           |
| 500      | [500]            |
| 1500     | [1000, 500]      |
| 100      | [100]            |
| 1100     | [1000, 100]      |
| 600      | [500, 100]       |
| 1600     | [1000, 500, 100] |

**Результат**

Ищем в таблице ключ **1100** и получаем ответ **[1000, 100]**

Обратите внимание, что если на одном из шагов мы бы получили одинаковую сумму с помощью разных купюр, то в таблицу следует записать результат, который содержит наименьшее количество купюр.
В нашем случае мы перебираем купюры от больших к меньшим, поэтому мы отдаем приоритет уже записанному в таблицу значению. Таким образом мы получим оптимальный результат.


**Алгоритм:**
1. Заводим таблицу для хранения суммы и купюр
2. Делаем цикл от 1 до N элементов, где N количество купюр и для каждого n рассчитываем:
    1. Создаем временную таблицу
    2. Копируем каждую строку из основной таблицы, добавляем к ней текущую купюру и записываем во временную таблицу
    3. Копируем значения из временой таблицы в основную
    4. Если в основной таблице уже есть строка с такой суммой, то отдаем приоритет значению из временной таблицы
3. Ищем в таблице строку с нужной суммой и выводим ответ. Если такой строки нет, то решение для данных значений отсутсвует.

**Код:**

%% СМОТРИ РЕШЕНИЕ В dynamic.js %%

**Сложность алгоритма:**

Для решения это задачи мы перебираем N купюр и для каждой купюры перебираем S элементов в основной таблице.
Максимальное возможное число строк в таблице равно сумме снятия

Итого сложность алгоритма O(NS), где N - количество купюр, S - сумма для снятия
